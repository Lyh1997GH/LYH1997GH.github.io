---
layout:     post
title:      时间、空间复杂度分析
subtitle:   时间、空间复杂度分析总结
date:       2019-05-09
author:     Xionghz
header-img: 
catalog: true
tags:
    - 算法与数据结构
---

# 时间、空间复杂度分析

## 1.事后统计法

 1. 测试结果非常依赖测试环境<br/>测试环境的硬件的不同对于程序运行的结果会产生很大的不同
 2. 测试结果受数据规模的影响很大

## 2.大O复杂度表示法
 
算法的执行效率，就是算法代码执行的时间。但是，如何在不运行代码的情况下，用“肉眼”得到一段代码的执行时间呢? 这里有段非常简单的代码。
 
```java
//求 1,2,3...n 的累加和
public int call(int num){
    int sum=0;
    for(int i=1;i<=num;++i){
        sum=sum+i;
    }
    return sum;
}
```
假设每一行代码执行的时间都一样为`unit_time`。那么第2行的需要一个`unit_time`，第3、4行都运行了n遍，那么他的执行时间为`2n * unit_time`。所以总的代码执行时间`(2n + 1) * unit_time`。
总结一下：**所有代码的执行时间`T(n)`与每行代码的执行次数成正比。**

 ___________

接下来我们再看一段代码：

```java
public int call(int n) {
   int sum = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1;
     for (; j <= n; ++j) {
        sum = sum + i * j;
     } 
   }
} 
```

我们依旧假设每个语句的执行时间是`unit_time`。那这段代码的总执行时间`T(n)`是多少呢?
第2、3、4行代码，每行都需要1个`unit_time`的执行时间，第5、6行代码循环执行了n遍，需要`2n * unit_time`的执行时间，第7、8行代码循环执行了n<sup>2</sup>，所以需
要 2n<sup>2</sup> * unit_time 的执行时间。所以，整段代码总的执行时间T(n) = (2n<sup>2</sup>+2n+3)*time。

规律：**所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。**

![](https://ws2.sinaimg.cn/large/006tNc79ly1g2utxrjnbyj30do02yt8l.jpg)

T(n) 表示代码的执行时间；n 表示数据规模的大小；f(n) 表示每行代码执行次数的总和；O 表示代码的执行时间 T(n) 与 f(n) 表达式成正比。这就是大O复杂度表示法。它实际上并不代表代码具体的运行时间，而是表示代码执行时间随着数据规模增长的变化趋势。也叫做渐进时间复杂度。简称时间复杂度。

当 n 很大时，如10000、100000。而公式中的系数、常量、低阶这三部分并不左右增长趋势，都可忽略。取最大量级就可以了：T(n) = O(n); T(n) = O(n<sup>2</sup>)。

## 3.时间复杂度分析
如何快速分析一段程序的时间复杂度。可以使用一下三个方法：

 * 3.1 只关注循环执行次数最多的一段代码

 因为大O复杂度法表示一种变化趋势，我们通常会忽略掉`低阶、系数、常量`，只取最大阶的量级就行。所以只需关注循环执行次数最多的一段代码就行了，这段代码执行次数的n的量级，就是此段的时间复杂度。比如
 
```java
//求 1,2,3...n 的累加和
public int call(int num){
    int sum=0;
    for(int i=1;i<=num;++i){
        sum=sum+i;
    }
    return sum;
}
```
第3行代码是常量级的执行时间，与num的大小无关，所以对复杂度并没有影响。循环执行次数最多的是第4、5行代码，所以这块代码要重点分析。这两行代码被执行了n次，所以总的时间复杂度就是O(n)。

 * 3.2 加法法则：总复杂度等于量级最大的某段代码的复杂度
 
 这个代码分为三部分，分别是求sum_1、sum_2、sum_3。我们可以分别分析每一部分的时间复杂度，然后把它们放到一块儿，再取一个量级最大的作为整段代码 的复杂度。

```java
public int cal(int n) {
   int sum_1 = 0;
   int p = 1;
   for (; p < 100; ++p) {
     sum_1 = sum_1 + p;
   } 
   
   int sum_2 = 0;
   int q = 1;
   for (; q < n; ++q) {
     sum_2 = sum_2 + q;
   }
   
   int sum_3 = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1;
     for (; j <= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }  
  	 
   return sum_1 + sum_2 + sum_3;
}
```
 
这段代码循环了100次，但是这是常量的执行时间，跟n无关。所以可忽略。
——即便这段代码循环10000次、100000次，只要是一个已知的数，跟n无关，照样也是常量级的执行时间。当n无限大的时候，就可以忽略。尽管对代码的执行时间会有很大影响，但是回到时间复杂度的概念来说，它表示的是一个算法执行效率与数据规模增长的变化趋势，所以不管常量的执行时间多大，我们都可以忽略掉。因为它对增长趋势并没有影响。
第二段代码和第三段代码的时间复杂度是多少呢?答案是O(n)和O(n<sup>2</sup>)。
我们取最大的量级。所以复杂度为T(n)=O(n<sup>2</sup>).
规则：总的时间复杂度就等于量级最大的某段代码的时间复杂度。
如果`T1(n)=O(f(n))，T2(n)=O(g(n))`;那么`T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n)))`。

 * 3.3 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。

如果`T1(n)=O(f(n)),T2(n)=O(g(n))`;那么`T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))`。

```java
public int call(int n) {
   int ret = 0;
   int i = 1;
   for (; i < n; ++i) {
     ret = ret + f(i);
   } 
} 
 
public int f(int n) {
  int sum = 0;
  int i = 1;
  for (; i < n; ++i) {
    sum = sum + i;
  } 
  return sum
}
```

第4~6行的时间复杂度是`T1(n) = O(n)`。但f()函数本身不是一个简单的操作，它的时间复杂度是T2(n) = O(n)，所以call()函数的时间复杂度就是，T(n) = T1(n) * T2(n) = O(n*n) = O(n<sup>2</sup>)。

## 4.常见时间复杂度实例分析

![](https://ws2.sinaimg.cn/large/006tNc79ly1g2uzbf9lmmj30l70digo7.jpg)

----
大致可以分为两类：

 * 多项式量级
 * 非多项式量级(低效)：指数阶、阶乘阶

当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增大，求解问题的执行时间会无限增长。所以非多项式量级算法是非常低效的。

#### 4.1 常量阶 O(1)
O(1)是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有3行，它的时间复杂度也是O(1)， 而不是O(3)。

```java
public void call(){
  int i = 8;
  int j = 6;
  int sum = i + j;
}
```
**只要代码执行时间不随着n变大而增大，这种代码时间复杂度就为O(1)**.一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)
#### 4.2. 对数阶 O(logn)、线性阶 O(nlogn)
 * 对数阶时间复杂度非常常见，但也是最难分析的一种时间复杂度。比如：

```java
i=1;
while(i<=n){
    i=i * 2;
}
```

变量i的值从1开始取，每循环一次就乘以2。其实这是一个等比数列：
![](https://ws4.sinaimg.cn/large/006tNc79ly1g2v2zrez1rj30ig03at8s.jpg)
所以，我们知道了X的值就知道这行代码的执行次数了。x=log<sub>2</sub>n,那么这段代码的时间复杂度为O(log<sub>2</sub>n)。
 
 实际上，不管是以2为底、以3为底，还是以10为底，我们可以把所有对数阶的时间复杂度都记为O(logn)。
 因为对数之间是可以相互转换的，log<sub>3</sub>n 就等于log<sub>3</sub>2 * log<sub>2</sub>n,所以 O(log<sub>3</sub>n) = O(C * log<sub>2</sub>n)。其中C=log<sub>3</sub>2是一个常量。采用大O标记复杂度的时候，可以忽略系数。即**O(Cf(n)) = O(f(n))**。所以 O(log<sub>2</sub>n) 就等于O(log<sub>3</sub>n)。因此在对数阶时间复杂度里，我们会忽略对数的‘底’，表示为**O(logn)。**

* 线性对数阶其实就是 O(logn) 执行了 n 遍，即 O(nlogn)。

#### 4.3 常量阶 O(m+n)、O(m*n)
我们再来讲一种跟前面都不一样的时间复杂度，代码的复杂度由两个数据的规模来决定。

```java
public int call(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  } 
  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  } 
  return sum_1 + sum_2;
}
```
可以看出此函数有两个数据规模，我们无法评估这两个数据规模的量级，就不能简单地利用加法法则，省略掉其中一个，所以此时间复杂度为**O(m+n)**。
我们需要将加法规则改为:`T1(m) + T2(n) = O(f(m) + g(n))`。但是乘法法则继续有效:`T1(m)*T2(n) = O(f(m) * f(n))`。

## 5.空间复杂度分析
空间复杂度称为渐进空间复杂度，便是算法的存储空间与数据规模之间的增长关系。

```java
public void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  } 
  for (i = n-1; i >= 0; --i) {
    System.out.print(a[i]);
  } 
} 
```
第二行代码中申请了一个空间存储变量 i，但他是常量阶，跟数据规模 n 没关系，可忽略。第三行申 请了一个大小为n的int类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是O(n)。
我们常见的空间复杂度就是O(1)、O(n)、O(n2 )，像O(logn)、O(nlogn)这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。

## 6.总结

复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，**从低阶到高阶有: O(1)、O(logn)、O(n)、O(nlogn)、O(n2)。**

![](https://ws2.sinaimg.cn/large/006tNc79ly1g2v775pewej30nw0gftam.jpg)